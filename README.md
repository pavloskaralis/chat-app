Live Link: http://astral-chat-app.herokuapp.com/

Purpose: Astral is a multi-room chat application that relies on Django Channels to create a databaseless environment. Through the React client, users are able to access existing rooms within a lobby view, or create their own public and private chats. These rooms accommodate for up to 8 users and are programmed to delete when empty. 

Technologies: React, React Router, Python, Django, Django Channels, SCSS

Backend Overview: As stated, the server is built using the Django framework, and employs Django Channels for its live-update interface via two consumers. When the site is visited, a websocket connection is first routed to the lobby consumer, which is responsible for updating the active room list, processing new rooms, and facilitating access to existing rooms. When receiving a request to create a new room, this consumer will check whether that name is already taken. Rather than being stored in a database, information on rooms is kept within two distinct arrays: one designed to send data back to the client, and the other for housing room passwords and hashes. In order to access a private room, a correct password must be provided for the consumer to return the required URL hash parameter. For both public and private rooms, a display name is also required by the server, and is checked against existing names within the specific room. Once the client redirects a user to the chat’s URL, another websocket connection is made, only this time it is processed by the chat consumer. This consumer is responsible for passing messages between clients in real time, as well as updating a list of connected users. The previously mentioned data array also stores a room’s message history should a user temporarily leave the chat. Once a room is completely empty however, all this data gets deleted from the server. 

Frontend Overview: The application’s frontend is built using React though employs a Vue.js organizational strategy of separating structures into views and components. In total, there exist 3 views that represent the app’s pages – Home, Lobby, and Chat – as well as 10 other components reused within those structures. On the Home page, a user has the option of either creating a chat or joining an existing room. The form component that gets toggled by the create button, is actually dynamically programmed to render 3 different form types depending on the button used to access it. Within the lobby view there exists 1 search, 1 exit, and 3 toggle components. The exit component is essentially a button that allows for a user to quit the lobby or chat. In regard to the search bar, it filters the lobby’s room list based on matching names, while the toggle components allow a user to sort this list by either name, capacity, or access. In addition to the above, the client renders a room component for each existing room in the lobby’s state. This component essentially depicts information about a room, as well as provides a connect button that prompts an access form. Depending on whether a chat is public or private, the form will render a password field. Should authorization be successful, the client will redirect the user to a URL containing the room’s name and secret hash. Finally, within this Chat view exists another search component, which gets reused to filter chat messages by content or display name. For each message that gets sent, a message component is dynamically rendered based on whether its author is the user or another accessing client. This is made possible because the client retrieves the display name stored within its connection from the consumer, and then compares it against the display name property of each message object. 

